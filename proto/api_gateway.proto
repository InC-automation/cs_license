syntax = "proto3";
option cc_enable_arenas = true;

package api_gateway;

/**
 * Сервис ApiGateway.
 * Файл содержит protobuf схему данных для Эликонт-КС версий 2.X.X для обеспечения информационного обмена c микросервисом ApiGateway.
 * Дата: 21.10.2025
 * (C) 2025 АО "ЭЛАРА". Все права защищены.
 * 
 * АО "ЭЛАРА" предоставляет данный файл как открытый элемент программного продукта Эликонт-КС.
 * Внесение изменений в данный файл может нарушить работоспособность производного кода и связанных с ним пользовательских решений.
 * АО "ЭЛАРА" не несёт ответственность за программный код, созданный сторонними разработчиками для обеспечения информационного обмена с Эликонт-КС и использующий данный файл.
 *
 * Лицензирование:
 * Откройте раздел "Лицензия" в документации к продукту для получения подробной информации.
 *
 */
service ApiGateway {
	/**
	* Задать конфигурацию коммуникационного сервера.
	* Отправляемый xml-файл должен соответствовать схеме для текущей версии коммуникационного сервера
	*/
    rpc SetConfig (stream FilePart) returns (SetConfigResult) {}
    
	/**
	* Получить состояние конфигурации коммуникационного сервера
	*/
	rpc GetConfigState(Empty) returns (ConfigState) {}

	/**
	* Получить состояние каналов коммуникационного сервера
	*/
	rpc GetChannelsState(Empty) returns (ChannelsState) {}
	
	/**
	* Включить канал с указанным GUID
	*/
	rpc TurnOnChannel(Guid) returns (Result) {}
	
	/**
	* Выключить канал с указанным GUID
	*/
	rpc TurnOffChannel(Guid) returns (Result) {}
	
	/**
	* Получить информацию о состоянии коммуникационного сервера
	*/
	rpc GetCsInfo(Empty) returns (CsInfo) {}
	
	/**
	* Получить состояние лицензии коммуникационного сервера
	*/
	rpc GetLicenseState(Empty) returns (LicenseState) {}
	
	/**
	* Включить трассировку канала с указанным GUID.
	* Если указанный канал не поддерживает трассировку, то сообщений трассировки от этого канала приходить не будет вне зависимости, включена ли трассировка на нём или нет
	*/
	rpc TraceOn(Guid) returns (Result) {}

	/**
	* Выключить трассировку канала с указанным GUID.
	* Если указанный канал не поддерживает трассировку, то сообщений трассировки от этого канала приходить не будет вне зависимости, включена ли трассировка на нём или нет
	*/
	rpc TraceOff(Guid) returns (Result) {}
	
	/**
	* Получить состояние баз данных, используемых коммуникационным сервером для архивации
	*/
	rpc GetDatabasesState(Empty) returns (DatabasesState) {}
	
	/**
	* Получить последние лог-сообщения коммуникационного сервера.
	* Вызов этой функции возвращает накопленные сообщения относительно предыдущего вызова
	*/
	rpc GetLogMessages(Empty) returns(Messages) {}
	
	/**
	* Получить последние сообщения трассировки каналов коммуникационного сервера.
	* Вызов этой функции возвращает накопленные сообщения относительно предыдущего вызова
	*/
    rpc GetTraceMessages(Empty) returns(TraceMessages) {}
}

/*
 * Сообщение, определяющее результат выполнения какой-либо операции
 */
message Result { 
	enum ErrorCode {
		SUCCESS = 0;					// Успех
		FAIL = 1;						// Ошибка
	}
	ErrorCode value = 1;				// Результат
	string error = 2;					// Текст ошибки (в случае ошибки)
}

/*
 * Определение пустого сообщения
 */
message Empty {}

/*
 * Сообщение, определяющее GUID объекта. 
 */
message Guid {
	string value = 1; 					// Строковое представление GUID в формате с дефисами: 01234567-89ab-cdef-0123-456789abcdef
}

/*
 * Сообщение, определяющее список наименований протоколов для метрики
 */
message ProtocolSet {
    repeated string protocol = 1;		// Список наименований протоколов
}

/*
 * Сообщение, определяющее список наименований функций для метрики. 
 */
message FunctionSet {
    repeated string function = 1;		// Список наименований функций
}

/*
 * Сообщение, определяющее метрику.
 */
message Metrics{
	ProtocolSet client_protocols = 1;	// Доступные клиентские протоколы
	ProtocolSet server_protocols = 2;	// Доступные серверные протоколы
	uint32 max_signal_count = 3;		// Максимальное количество сигналов и команд
	FunctionSet functions = 4;			// Доступные функции
}

/*
 * Сообщение, определяющее состояние лицензии коммуникационного сервера
 */
message LicenseState {
    string key_id = 1;					// Идентификатор ключа

    enum Mode {
        NORMAL = 0; 					// Система лицензирования не накладывает ограничений на работу приложения
        RESTRICTED = 1; 				// Ограниченный режим. Через некоторое время приложение автоматически завершится
    }

    enum KeyState {
        ePresent = 0;					// Ключ присутсвует
        eMissing = 1;					// Ключ отсутствует
        eExtracted = 2; 				// Был зарегистрирован ключ, потом был извлечён или стал недоступен
    }
	
    KeyState key_presence = 2;			// Состояние ключа
    Mode mode = 3;						// Режим
    uint32 time_left = 4; 				// Время до окончания в секундах
    Metrics current_metrics = 5;		// Текущая метрика
    Metrics current_restrictions = 6;   // Текущие ограничения
}

/*
 * Сообщение, определяющее состояние резервирования канала коммуникационного сервера
 */
message ChannelRedundancyState {
	enum Activity {
		UNKNOWN = 0;					// Не определено
		MAIN = 1;						// Основной
		RESERVE = 2;					// Резервный
	}
	enum LinkState {
		DISCONNECTED = 0;				// Отключен
		CONNECTED = 1;					// Подключен
	}
	Activity activity = 1;				// Активность.
	LinkState main = 2;					// Состояние основного канала данных
	LinkState reserve = 3;				// Состояние резервного канала данных
}

/*
 * Сообщение, определяющее состояние канала коммуникационного сервера
 */
message ChannelState {
	enum State {
		ENABLED = 0;					// Активирован
		DISABLED = 1;					// Деактивирован
		CONNECTED = 2;					// Подключен
	}
	Guid guid = 1;						// GUID канала.
	State state = 2;					// Состояние канала.
	ChannelRedundancyState redundancy_state = 3;	// Состояние резервирования
	
	string error = 4;					// Пусто, если в работе канала нет ошибок. В противном случае - текст ошибки
}

/*
 * Сообщение, определяющее состояние всех каналов коммуникационного сервера
 */
message ChannelsState {
	string error = 1;					// Пусто, если в работе каналов нет ошибок. В противном случае - текст ошибки
	repeated ChannelState channels = 2; // Список состояний каналов
}

/*
 * Сообщение, определяющее результат загрузки конфигурации в коммуникационного сервера
 */
message SetConfigResult {
    enum Result {
	    SUCCESS = 0;					// Успешно
	    BUSY = 1;						// В обработке
		FAIL = 2;						// Ошибка загрузки
    }
    Result value = 1;					// Результат.
	string error = 2;					// Пусто, если загрузка конфигурации успешна. В противном случае - текст ошибки
}

/*
 * Сообщение, определяющее информацию о коммуникационном сервере
 */
message CsInfo {
    enum PollMethod {
		SINGLE_THREAD = 0;				// Однопоточный
		MULTI_THREAD = 1;				// Многопоточный
	}

    string version = 1;					// Версия коммуникационного сервера
    repeated string protocols = 2;		// Список поддерживаемых протоколов
    PollMethod channels_poll_method = 3;	// Метод обработки каналов
	uint32 cs_id = 4;					// Идентификатор коммуникационного сервера
}

/*
 * Сообщение, определяющее версию конфигурации.
 */
message ConfigVersion {
    string value = 1;					// Версия конфигурации в виде строки
}

/*
 * Сообщение, определяющее часть файла.
 */
message FilePart {
    bytes buffer = 1;					// Байтовый буфер
}

/*
 * Сообщение, определяющее текущее состояние конфигурации коммуникационного сервера
 */
message ConfigState {
    enum State {
	    SUCCESS = 0;					// Успешно
		IN_PROGRESS = 1;				// Конфигурация разворачивается
		FAIL = 2;						// Ошибка конфигурации
	}
	
	ConfigVersion current_version = 1;	// Текущая версия конфигурации
	ConfigVersion last_version = 2;		// Последняя версия конфигурации
	State last_state = 3;				// Последнее состояние
	string last_error = 4;				// Последняя ошибка
	uint32 last_error_code = 5;			// Последний код ошибки
}

/*
 * Сообщение, определяющее состояние БД архива коммуникационного сервера
 */
message DatabaseState {
	enum ConnectionStatus {
	    DISCONNECTED = 0;				// Нет соединения
	    CONNECTED = 1;					// Подключена
    }
	enum DatabaseType {
		eINTERNAL = 0;					// Внутренняя (SQLite)
		ePOSTGRESQL = 1;				// Внешняя PortgreSQL
		eUNKNOWN = 3;					// Неизвестный тип
	}
	ConnectionStatus connection_status = 1;	// Статус соединения с БД архива
	DatabaseType db_type = 2;			// Тип БД архива
}

/*
 * Сообщение, определяющее состояние всех активных БД архива коммуникационного сервера
 */
message DatabasesState {
	repeated DatabaseState db_state = 1;	// Список состояний
}

/*
 * Уровни логирования коммуникационного сервера.
 */
enum Level {
    eTRACE = 0;							// Сообщения, используемые для трассировки
    eEMERGENCY = 1;						// Системные сообщения, указывающие на неработоспособность системы
    eALERT = 2;							// Сообщения, требующие немедленного вмешательства
    eCRITICAL = 3;						// Критические события, например, отказ в выделении памяти
    eERROR = 4;							// Сообщения об ошибках общего характера
    eWARNING = 5;						// Предупреждения о потенциальных проблемах
    eNOTICE = 6;						// Важные события, требующие внимания
    eINFO = 7;							// Информационные сообщения о нормальной работе системы
    eDEBUG = 8;							// Сообщения, используемые для отладки
} 

/*
 * Сообщение, определяющее сообщение лога.
 */
message OwnedMessage {
    string text = 1;					// Тескт сообщения лога
    Level level = 2;					// Уровень
    string source_id = 3;				// Идентификатор источника
    int64 time = 4;						// Время
}

/*
 * Сообщение, определяющее отдельное сообщения лога
 */
message Messages {
    repeated OwnedMessage messages = 1;	// Список сообщений
}

/*
 * Сообщение, определяющее отдельное сообщение трассировки
 */
message TraceMessage {
    string text = 1;					// Текст сообщения трассировки
    string guid = 2;					// Идентификатор источника
    int64 time = 3;						// Время
}

/*
 * Сообщение, определяющее сообщения трассировки
 */
message TraceMessages {
    repeated TraceMessage messages = 1;	// Список сообщений
}